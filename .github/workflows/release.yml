name: Build and Release

on:
  push:
    tags:
      - 'v*'  # 当推送以 'v' 开头的标签时触发，如 v1.0.0, v2.1.3

jobs:
  build:
    name: Build for multiple platforms
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: windows
            goarch: amd64
            suffix: .exe
            name: windows-amd64
          - goos: windows
            goarch: arm64
            suffix: .exe
            name: windows-arm64
          - goos: darwin
            goarch: amd64
            suffix: ""
            name: macos-amd64
          - goos: darwin
            goarch: arm64
            suffix: ""
            name: macos-arm64
          - goos: linux
            goarch: amd64
            suffix: ""
            name: linux-amd64
          - goos: linux
            goarch: arm64
            suffix: ""
            name: linux-arm64

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Install dependencies
      run: |
        go mod download
        go mod verify

    # 新增：安装Python和fonttools用于字体子集化
    - name: Set up Python for font subsetting
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install fonttools for font subsetting
      run: |
        pip install fonttools
        echo "✅ 已安装字体子集化工具"

    # 新增：安装UPX压缩工具
    - name: Install UPX
      run: |
        sudo apt-get update
        sudo apt-get install -y upx-ucl
        upx --version
        echo "✅ 已安装UPX压缩工具"

    # 安装平台特定的构建依赖
    - name: Install build dependencies for Linux
      if: matrix.goos == 'linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-multilib libc6-dev
        # 安装 Fyne 所需的依赖
        sudo apt-get install -y libgl1-mesa-dev xorg-dev

    # 增强Windows构建支持
    - name: Install cross-compilation tools for Windows
      if: matrix.goos == 'windows'
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-mingw-w64
        if [ "${{ matrix.goarch }}" = "arm64" ]; then
          # 检查ARM64编译器是否可用
          if ! which aarch64-w64-mingw32-gcc > /dev/null; then
            echo "⚠️ 警告: Windows ARM64 编译器不可用，尝试安装替代方案..."
            # 尝试安装替代方案，根据Ubuntu版本可能会有不同的包名
            sudo apt-get install -y gcc-mingw-w64-aarch64 || true
          fi
        fi

    # 增强macOS构建支持
    - name: Setup macOS cross-compilation (if needed)
      if: matrix.goos == 'darwin'
      run: |
        echo "ℹ️ 设置macOS交叉编译环境..."
        # macOS交叉编译通常不需要特殊的编译器，但需要特殊处理
        # 记录当前环境以便调试
        go env

    # 替换：使用Python脚本从源码中提取中文字符
    - name: Extract Chinese characters from source code
      run: |
        echo "📝 从源码中提取中文字符..."
        
        # 创建Python脚本来提取中文字符
        cat > extract_chinese.py << 'EOF'
        import os
        import re
        import sys

        def is_chinese(c):
            # 检查是否是中文字符（Unicode范围）
            return '\u4e00' <= c <= '\u9fff'

        def extract_chinese_from_file(filename):
            chinese_chars = set()
            try:
                with open(filename, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    # 提取双引号中的字符串
                    double_quotes = re.findall(r'"([^"]*)"', content)
                    for s in double_quotes:
                        for c in s:
                            if is_chinese(c):
                                chinese_chars.update(s)
                                break
                    
                    # 提取单引号中的字符串
                    single_quotes = re.findall(r"'([^']*)'", content)
                    for s in single_quotes:
                        for c in s:
                            if is_chinese(c):
                                chinese_chars.update(s)
                                break
            except Exception as e:
                print(f"警告: 处理文件 {filename} 时出错: {e}", file=sys.stderr)
            
            return chinese_chars

        def main():
            all_chinese = set()
            count = 0
            
            # 递归遍历所有Go文件
            for root, _, files in os.walk('.'):
                for file in files:
                    if file.endswith('.go'):
                        file_path = os.path.join(root, file)
                        chinese_in_file = extract_chinese_from_file(file_path)
                        all_chinese.update(chinese_in_file)
                        if chinese_in_file:
                            count += 1
            
            # 确保基本ASCII字符也被包含
            ascii_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ,.?!@#$%^&*()_+-=[]{}|;:\"'<>/`~"
            all_chars = all_chinese.union(set(ascii_chars))
            
            # 写入到文件
            with open('chinese_chars.txt', 'w', encoding='utf-8') as f:
                f.write(''.join(all_chars))
            
            print(f"✅ 中文字符提取完成，处理了 {count} 个包含中文的文件")
            print(f"📊 统计信息:")
            print(f"- 总字符数: {len(all_chars)}")
            print(f"- 中文字符数: {len([c for c in all_chars if is_chinese(c)])}")
            
            # 打印样例（最多20个字符）
            sample = ''.join(list(all_chars)[:20])
            print(f"- 字符样例: {sample}")

        if __name__ == '__main__':
            main()
        EOF
        
        # 执行Python脚本
        python extract_chinese.py
        
        echo "📄 中文字符文件内容预览:"
        head -c 100 chinese_chars.txt

    # 加强字体子集化步骤的错误处理
    - name: Create font subset
      run: |
        echo "📝 开始字体子集化..."
        
        # 检查字体文件是否存在
        if [ ! -f "gui/NotoSansSC-Regular.ttf" ]; then
          echo "❌ 错误: 字体文件不存在: gui/NotoSansSC-Regular.ttf"
          # 列出目录内容以调试
          echo "目录内容:"
          ls -la gui/
          exit 1
        fi
        
        # 检查中文字符文件是否存在
        if [ ! -f "chinese_chars.txt" ]; then
          echo "❌ 错误: 中文字符文件不存在: chinese_chars.txt"
          exit 1
        fi
        
        # 创建字体子集，添加错误处理
        if ! pyftsubset gui/NotoSansSC-Regular.ttf --text-file=chinese_chars.txt --output-file=gui/NotoSansSC-Subset.ttf; then
          echo "❌ 字体子集化失败，尝试使用基本选项..."
          # 尝试简化的子集化命令
          pyftsubset gui/NotoSansSC-Regular.ttf --text="测试中文" --output-file=gui/NotoSansSC-Subset.ttf
        fi
        
        # 验证子集字体是否创建成功
        if [ ! -f "gui/NotoSansSC-Subset.ttf" ]; then
          echo "❌ 错误: 子集字体文件创建失败"
          # 复制原始字体作为备用方案
          cp gui/NotoSansSC-Regular.ttf gui/NotoSansSC-Subset.ttf
          echo "⚠️ 使用原始字体作为备用方案"
        else
          # 检查字体文件大小
          ORIGINAL_SIZE=$(stat -c %s gui/NotoSansSC-Regular.ttf)
          SUBSET_SIZE=$(stat -c %s gui/NotoSansSC-Subset.ttf)
          SAVED_SIZE=$((ORIGINAL_SIZE - SUBSET_SIZE))
          SAVED_PERCENT=$((SAVED_SIZE * 100 / ORIGINAL_SIZE))
          
          echo "📊 字体文件大小对比:"
          echo "- 原始字体: $ORIGINAL_SIZE 字节"
          echo "- 子集字体: $SUBSET_SIZE 字节"
          echo "- 节省空间: $SAVED_SIZE 字节 ($SAVED_PERCENT%)"
        fi
        
        # 修改resources.go文件以使用子集字体
        if [ -f "gui/resources.go" ]; then
          sed -i 's/NotoSansSC-Regular.ttf/NotoSansSC-Subset.ttf/g' gui/resources.go
          echo "✅ 更新resources.go使用子集字体"
        else
          echo "❌ 错误: resources.go文件不存在"
        fi

    # 增强构建步骤，添加更多错误处理和调试信息
    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 1
      run: |
        echo "🔨 开始为 ${{ matrix.goos }}-${{ matrix.goarch }} 构建二进制文件..."
        
        # 设置交叉编译环境
        if [ "${{ matrix.goos }}" = "windows" ]; then
          if [ "${{ matrix.goarch }}" = "amd64" ]; then
            export CC=x86_64-w64-mingw32-gcc
            export CXX=x86_64-w64-mingw32-g++
          elif [ "${{ matrix.goarch }}" = "arm64" ]; then
            # 尝试使用aarch64编译器，如果不可用则报告
            if which aarch64-w64-mingw32-gcc > /dev/null; then
              export CC=aarch64-w64-mingw32-gcc
              export CXX=aarch64-w64-mingw32-g++
            else
              echo "⚠️ 警告: Windows ARM64 编译器不可用，构建可能会失败"
            fi
          fi
        elif [ "${{ matrix.goos }}" = "darwin" ]; then
          # macOS构建可能需要特殊处理
          echo "ℹ️ 设置macOS构建环境"
          # 对于macOS构建，通常不需要设置CC/CXX
        fi
        
        # 显示编译环境信息
        echo "📋 编译环境信息:"
        echo "- GOOS: $GOOS"
        echo "- GOARCH: $GOARCH"
        echo "- CGO_ENABLED: $CGO_ENABLED"
        echo "- CC: ${CC:-未设置}"
        echo "- CXX: ${CXX:-未设置}"
        
        # 构建二进制文件，添加额外的优化选项
        OUTPUT_NAME="Cursor_Windsurf_Reset-${{ matrix.name }}${{ matrix.suffix }}"
        echo "🔧 执行构建命令: go build -ldflags=\"-s -w -X main.version=${{ github.ref_name }}\" -o \"${OUTPUT_NAME}\" main.go"
        
        # 尝试构建，如果失败则提供详细日志
        if ! go build -ldflags="-s -w -X main.version=${{ github.ref_name }}" -o "${OUTPUT_NAME}" main.go; then
          echo "❌ 构建失败，显示详细日志"
          go build -v -x -ldflags="-s -w -X main.version=${{ github.ref_name }}" -o "${OUTPUT_NAME}" main.go || true
          # 检查常见的失败原因
          echo "📋 诊断信息:"
          go env
          echo "⚠️ 构建失败，跳过后续步骤"
          exit 1
        fi
        
        # 记录构建前的文件大小
        ORIGINAL_SIZE=$(stat -c %s "${OUTPUT_NAME}")
        echo "📊 原始二进制文件大小: ${ORIGINAL_SIZE} 字节"
        
        # 验证文件是否创建成功
        if [ -f "${OUTPUT_NAME}" ]; then
          echo "✅ 构建成功: ${OUTPUT_NAME}"
          ls -la "${OUTPUT_NAME}"
        else
          echo "❌ 构建失败: ${OUTPUT_NAME} 文件不存在"
          exit 1
        fi
        
        # 使用UPX压缩二进制文件
        echo "📦 开始UPX压缩..."
        if ! upx --best "${OUTPUT_NAME}"; then
          echo "⚠️ UPX压缩失败，尝试使用普通模式"
          upx "${OUTPUT_NAME}" || echo "❌ UPX压缩完全失败，使用未压缩文件"
        fi
        
        # 记录压缩后的文件大小
        COMPRESSED_SIZE=$(stat -c %s "${OUTPUT_NAME}")
        SAVED_SIZE=$((ORIGINAL_SIZE - COMPRESSED_SIZE))
        SAVED_PERCENT=$((SAVED_SIZE * 100 / ORIGINAL_SIZE))
        
        echo "📊 压缩效果:"
        echo "- 压缩前: ${ORIGINAL_SIZE} 字节"
        echo "- 压缩后: ${COMPRESSED_SIZE} 字节"
        echo "- 节省空间: ${SAVED_SIZE} 字节 (${SAVED_PERCENT}%)"
        
        # 创建优化指标文件，供后续发布步骤使用
        echo "${ORIGINAL_SIZE},${COMPRESSED_SIZE},${SAVED_SIZE},${SAVED_PERCENT}" > "${OUTPUT_NAME}.metrics"

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: Cursor_Windsurf_Reset-${{ matrix.name }}
        path: |
          Cursor_Windsurf_Reset-${{ matrix.name }}${{ matrix.suffix }}
          Cursor_Windsurf_Reset-${{ matrix.name }}${{ matrix.suffix }}.metrics

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v3

    - name: Display structure of downloaded files
      run: |
        echo "📁 下载的文件结构:"
        find . -name "Cursor_Windsurf_Reset-*" -type f | sort

    - name: Prepare release files
      run: |
        mkdir -p release-files
        
        # 移动所有构建的二进制文件到 release-files 目录
        find . -name "Cursor_Windsurf_Reset-*" -type f -executable -o -name "*.exe" | while read file; do
          if [ -f "$file" ]; then
            cp "$file" release-files/
            echo "✅ 复制文件: $file -> release-files/"
          fi
        done
        
        # 复制配置文件和文档（修正文件名）
        if [ -f "reset_config.json" ]; then
          cp reset_config.json release-files/
          echo "✅ 复制文件: reset_config.json -> release-files/"
        else
          echo "⚠️ 警告: reset_config.json 不存在"
        fi
        
        if [ -f "README.md" ]; then
          cp README.md release-files/
          echo "✅ 复制文件: README.md -> release-files/"
        else
          echo "⚠️ 警告: README.md 不存在"
        fi
        
        echo "📦 准备发布的文件:"
        ls -la release-files/

    # 新增：收集所有平台的优化指标
    - name: Collect optimization metrics
      id: collect_metrics
      run: |
        echo "📊 收集优化指标..."
        TOTAL_ORIGINAL_SIZE=0
        TOTAL_COMPRESSED_SIZE=0
        
        echo "| 平台 | 原始大小 | 优化后大小 | 节省空间 | 压缩率 |" > optimization_metrics.md
        echo "|------|----------|------------|----------|--------|" >> optimization_metrics.md
        
        # 查找所有指标文件
        METRICS_FILES=$(find . -name "*.metrics" 2>/dev/null || echo "")
        
        if [ -z "$METRICS_FILES" ]; then
          echo "⚠️ 警告: 未找到指标文件，无法生成优化报告"
          echo "| 无数据 | - | - | - | - |" >> optimization_metrics.md
        else
          while read metrics_file; do
            PLATFORM=$(basename $metrics_file .metrics)
            
            if [ ! -f "$metrics_file" ]; then
              echo "⚠️ 警告: 指标文件不存在: $metrics_file"
              continue
            fi
            
            METRICS=$(cat $metrics_file)
            
            # 处理可能的格式错误
            if [[ $METRICS != *","* ]]; then
              echo "⚠️ 警告: 指标文件格式错误: $metrics_file"
              continue
            fi
            
            IFS=',' read -r ORIGINAL_SIZE COMPRESSED_SIZE SAVED_SIZE SAVED_PERCENT <<< "$METRICS"
            
            # 检查是否成功解析数值
            if [[ ! "$ORIGINAL_SIZE" =~ ^[0-9]+$ ]]; then
              echo "⚠️ 警告: 无法解析原始大小: $ORIGINAL_SIZE"
              continue
            fi
            
            ORIGINAL_SIZE_MB=$(echo "scale=2; $ORIGINAL_SIZE/1048576" | bc)
            COMPRESSED_SIZE_MB=$(echo "scale=2; $COMPRESSED_SIZE/1048576" | bc)
            SAVED_SIZE_MB=$(echo "scale=2; $SAVED_SIZE/1048576" | bc)
            
            echo "| $PLATFORM | ${ORIGINAL_SIZE_MB} MB | ${COMPRESSED_SIZE_MB} MB | ${SAVED_SIZE_MB} MB | ${SAVED_PERCENT}% |" >> optimization_metrics.md
            
            TOTAL_ORIGINAL_SIZE=$((TOTAL_ORIGINAL_SIZE + ORIGINAL_SIZE))
            TOTAL_COMPRESSED_SIZE=$((TOTAL_COMPRESSED_SIZE + COMPRESSED_SIZE))
          done <<< "$METRICS_FILES"
          
          # 只有在有数据的情况下才计算总计
          if [ $TOTAL_ORIGINAL_SIZE -gt 0 ]; then
            TOTAL_SAVED_SIZE=$((TOTAL_ORIGINAL_SIZE - TOTAL_COMPRESSED_SIZE))
            TOTAL_SAVED_PERCENT=$((TOTAL_SAVED_SIZE * 100 / TOTAL_ORIGINAL_SIZE))
            TOTAL_ORIGINAL_SIZE_MB=$(echo "scale=2; $TOTAL_ORIGINAL_SIZE/1048576" | bc)
            TOTAL_COMPRESSED_SIZE_MB=$(echo "scale=2; $TOTAL_COMPRESSED_SIZE/1048576" | bc)
            TOTAL_SAVED_SIZE_MB=$(echo "scale=2; $TOTAL_SAVED_SIZE/1048576" | bc)
            
            echo "| **总计** | **${TOTAL_ORIGINAL_SIZE_MB} MB** | **${TOTAL_COMPRESSED_SIZE_MB} MB** | **${TOTAL_SAVED_SIZE_MB} MB** | **${TOTAL_SAVED_PERCENT}%** |" >> optimization_metrics.md
          fi
        fi
        
        echo "✅ 优化指标收集完成"
        cat optimization_metrics.md

    - name: Generate release notes
      id: release_notes
      run: |
        TAG_NAME=${{ github.ref_name }}
        echo "🎉 Cursor & Windsurf 重置工具 ${TAG_NAME}" > release_notes.md
        echo "" >> release_notes.md
        echo "## 📦 下载说明" >> release_notes.md
        echo "" >> release_notes.md
        echo "请根据您的操作系统下载对应的版本：" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Windows 用户" >> release_notes.md
        echo "- **Windows x64**: \`Cursor_Windsurf_Reset-windows-amd64.exe\`" >> release_notes.md
        echo "- **Windows ARM64**: \`Cursor_Windsurf_Reset-windows-arm64.exe\`" >> release_notes.md
        echo "" >> release_notes.md
        echo "### macOS 用户" >> release_notes.md
        echo "- **Intel Mac**: \`Cursor_Windsurf_Reset-macos-amd64\`" >> release_notes.md
        echo "- **Apple Silicon (M1/M2)**: \`Cursor_Windsurf_Reset-macos-arm64\`" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Linux 用户" >> release_notes.md
        echo "- **Linux x64**: \`Cursor_Windsurf_Reset-linux-amd64\`" >> release_notes.md
        echo "- **Linux ARM64**: \`Cursor_Windsurf_Reset-linux-arm64\`" >> release_notes.md
        echo "" >> release_notes.md
        echo "## 🚀 使用方法" >> release_notes.md
        echo "" >> release_notes.md
        echo "1. 下载对应平台的可执行文件" >> release_notes.md
        echo "2. 下载 \`reset_config.json\` 配置文件（可选）" >> release_notes.md
        echo "3. 双击运行（Windows）或在终端中执行" >> release_notes.md
        echo "4. 详细使用说明请参考 \`README.md\`" >> release_notes.md
        echo "" >> release_notes.md
        echo "## ⚠️ 注意事项" >> release_notes.md
        echo "" >> release_notes.md
        echo "- 使用前请备份重要数据" >> release_notes.md
        echo "- 确保 Cursor 和 Windsurf 应用已完全关闭" >> release_notes.md
        echo "- 首次运行可能需要管理员权限" >> release_notes.md
        echo "- macOS 和 Linux 用户可能需要添加执行权限：\`chmod +x Cursor_Windsurf_Reset-*\`" >> release_notes.md
        echo "" >> release_notes.md
        
        # 新增：添加优化信息到发布说明
        echo "## 📊 优化信息" >> release_notes.md
        echo "" >> release_notes.md
        echo "此版本应用了多项优化技术以减小二进制文件体积：" >> release_notes.md
        echo "" >> release_notes.md
        echo "1. 字体子集化：只保留应用中使用的中文字符" >> release_notes.md
        echo "2. UPX压缩：使用高效压缩算法减小可执行文件体积" >> release_notes.md
        echo "3. 链接优化：使用更优化的编译选项" >> release_notes.md
        echo "" >> release_notes.md
        echo "### 优化效果" >> release_notes.md
        echo "" >> release_notes.md
        cat optimization_metrics.md >> release_notes.md
        echo "" >> release_notes.md
        
        echo "## 🔧 技术信息" >> release_notes.md
        echo "" >> release_notes.md
        echo "- **版本**: ${TAG_NAME}" >> release_notes.md
        echo "- **构建时间**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> release_notes.md
        echo "- **Go 版本**: 1.21" >> release_notes.md
        echo "- **GUI 框架**: Fyne v2" >> release_notes.md
        
        echo "📝 生成的发布说明:"
        cat release_notes.md

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        name: "Cursor & Windsurf 重置工具 ${{ github.ref_name }}"
        body_path: release_notes.md
        draft: false
        prerelease: false
        files: |
          release-files/*
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload release summary
      run: |
        echo "🎉 发布完成！" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 📦 发布信息" >> $GITHUB_STEP_SUMMARY
        echo "- **标签**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **发布时间**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 📊 优化效果" >> $GITHUB_STEP_SUMMARY
        cat optimization_metrics.md >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 🔗 链接" >> $GITHUB_STEP_SUMMARY
        echo "- [查看发布页面](https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }})" >> $GITHUB_STEP_SUMMARY
        echo "- [下载文件](https://github.com/${{ github.repository }}/releases/latest)" >> $GITHUB_STEP_SUMMARY